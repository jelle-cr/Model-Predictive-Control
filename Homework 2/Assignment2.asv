close all;
clear all;
clc 

load 'stateMatrices.mat';

N = 10;
[n,m] = size(B);
x_ss = [10;1];
u_ss = 0.52;
x0 = [0.1; 1];          %original initial condition for x bar
%x0 = [5; -1];

shift = 'normal';       %switch between normal or shifted system       
shift = 'shifted';

%% Constraints          %defined on x bar
xmin = [-10;-1];
xmax = [5;2];
umin = -0.52;
umax = 0.43;

if(strcmp(shift,'shifted')~=1)
    xmin = xmin+x_ss;
    xmax = xmax+x_ss;
    umin = umin+u_ss;
    umax = umax+u_ss;
    x0 = x0+x_ss;
end


%% Cost function through LQR
Q = 1*eye(n);
R = 0.1;
%[K,P,~] = dlqr(A,B,Q,R);                   % find K and P through LQR
%K = -K;                                    % K and P are found through the LMI matrix later on

%leftInequality = (A+B*K)'*P*(A+B*K)-P;     % Just a check, to see whether the inequality holds
%rightInequality = -Q-K'*R*K;
%equal = leftInequality-rightInequality;

%% LMI
O = sdpvar(n,n);                            % O is symmetric, therefore O = O'
Y = sdpvar(m,n);
Con1 = [O, (A*O+B*Y)', O, Y';
    (A*O+B*Y), O, zeros(n,n), zeros(n,m);
    O, zeros(n,n), Q^-1, zeros(n,m);
    Y, zeros(m,n), zeros(m,n), R^-1]>=0;
Con2 = O>=1e-9;
constraints = Con1 + Con2;
diagnostics = optimize(constraints);
if diagnostics.problem == 0
    disp('Solver thinks it is feasible')
elseif diagnostics.problem == 1
    disp('Solver thinks it is infeasible')
else
    disp('Something else happened')
end
P = value(O)^-1;
K = value(Y)*value(O)^-1;

%leftInequality2 = (A+B*K)'*P*(A+B*K)-P;        % Just a check, to see whether the inequality holds
%rightInequality2 = -Q-K'*R*K;
%equal2 = leftInequality2-rightInequality2;

%% Terminal set
% Terminal constraint set                   %from instruction 5
% state constraints (A_x * x <= b_x)
X_set = Polyhedron([-eye(n);eye(n)],[-xmin;xmax]);
% input constraints (A_u * u <= b_u)
U_set = Polyhedron([-eye(m);eye(m)],[-umin;umax]);
% constraints admissible set
CA_set = Polyhedron([-eye(m);eye(m)]*K,[-umin;umax]);
% input constraint admissible set
IA_set = CA_set&X_set;

[Ccal, Dcal, Ecal, Mcal] = caligraphicMatricesTerminalSet(umin,umax,xmin,xmax,N,n,m,M_N,b_N);
[phi, gamma] = predictionModel(A,B,N,n,m);

L = Mcal*gamma + Ecal;
W = -Dcal-Mcal*phi;
%% MPC
k_sim = 300;
xk = [x0 zeros(n,k_sim+1)];     %state at each time index k
uk = zeros(m,k_sim+1);          %input at each time index k
                                %From Summary_con_MPC slide:
                                %quadprog(G,Fx(k),L,Ccal+Wx(k)
opt =  optimoptions('quadprog','Display','off');
warning('off','optim:quadprog:HessianNotSym');
for k = 1:k_sim+1
    [Uk,~,exitflag] = quadprog(G,F*xk(:,k),L,Ccal+W*xk(:,k),[],[],[],[],[],opt);
    if exitflag ~= 1
        warning('exitflag quadprog = %d\n', exitflag)
        if exitflag == -2
            sprintf('Optimization problem is infeasible.')
            break;
        end
    end
    uk(:,k) = Uk(1:m);
    xk(:,k+1) = A*xk(:,k)+B*uk(:,k);
end

%% Plotting
font = 14;
figure
subplot(1,2,1);
plot(0:k_sim,xk(:,1:length(xk)-1)',LineWidth=2);
xlim([0 k_sim]);
xlabel('$k$',Interpreter="latex",Fontsize=font);
if(strcmp('shifted',shift))
    ylabel('$\bar{x}$',Interpreter="latex",Fontsize=font);
    legend({'$\bar{x}_1$ (voltage)','$\bar{x}_2$ (current)'},Interpreter="latex",Fontsize=font);
else
    ylabel('$x$',Interpreter="latex",Fontsize=font);
    legend({'$x_1$ (voltage)','$x_2$ (current)'},Interpreter="latex",Fontsize=font);
end

subplot(1,2,2);
stairs(0:k_sim,uk,LineWidth=2);
xlim([0 k_sim]);
ylim([umin-0.1 umax+0.1]);
xlabel('$k$',Interpreter="latex",Fontsize=font);
if(strcmp('shifted',shift))
    ylabel('$\bar{u}$  (duty cycle)',Interpreter="latex",Fontsize=font);
else
    ylabel('$u$ (duty cycle)',Interpreter="latex",Fontsize=font);
end
sgtitle('Constrained MPC for the buck converter',Interpreter="latex",Fontsize=font+4)

